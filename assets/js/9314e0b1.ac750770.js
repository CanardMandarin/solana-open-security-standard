"use strict";(self.webpackChunksolana_open_security_standard=self.webpackChunksolana_open_security_standard||[]).push([[887],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=i,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||a;return n?r.createElement(m,o(o({ref:t},p),{},{components:n})):r.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9749:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(7462),i=(n(7294),n(3905));const a={},o="Missing Signer Check",s={unversionedId:"A02_account_validation/missing_signer_check",id:"A02_account_validation/missing_signer_check",title:"Missing Signer Check",description:"Description",source:"@site/docs/A02_account_validation/missing_signer_check.md",sourceDirName:"A02_account_validation",slug:"/A02_account_validation/missing_signer_check",permalink:"/solana-open-security-standard/docs/A02_account_validation/missing_signer_check",draft:!1,editUrl:"https://github.com/CanardMandarin/solana-open-security-standard/tree/main/docs/docs/A02_account_validation/missing_signer_check.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"A02 - Account Validation",permalink:"/solana-open-security-standard/docs/A02_account_validation/"},next:{title:"Missing Ownership Check",permalink:"/solana-open-security-standard/docs/A02_account_validation/missing_ownership_check"}},c={},l=[{value:"Description",id:"description",level:2},{value:"How To Prevent",id:"how-to-prevent",level:2},{value:"Example 1: Native Rust Program",id:"example-1-native-rust-program",level:2},{value:"Context",id:"context",level:3},{value:"Program Analysis",id:"program-analysis",level:3},{value:"Consequence",id:"consequence",level:3}],p={toc:l},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"missing-signer-check"},"Missing Signer Check"),(0,i.kt)("h1",{id:"missing-ownership-check"},"Missing Ownership Check"),(0,i.kt)("h2",{id:"description"},"Description"),(0,i.kt)("p",null,'Vulnerabilities known as "Missing Signer Check" are security flaws that occur when the validation of a transaction signer is not properly implemented. On the Solana blockchain, transactions are signed by accounts using their corresponding private keys to authorize actions or state modifications. These signatures ensure that only the rightful owner of an account can make changes to its data.'),(0,i.kt)("p",null,'When a program fails to validate the signer\'s identity before executing a transaction or modifying sensitive data, it opens the door for potential malicious actors to exploit the program. The "Missing Signer Check" vulnerability essentially allows unauthorized parties to perform actions as if they were legitimate account owners, generally leading to harmful scenarios.'),(0,i.kt)("h2",{id:"how-to-prevent"},"How To Prevent"),(0,i.kt)("p",null,'Preventing "Missing Signer Check" vulnerabilities in Solana programs is straightforward. Developers have to validate the ',(0,i.kt)("inlineCode",{parentName:"p"},"is_signer")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"AccountInfo")," struct. With this simple check, developers can ensure that only the rightful owner of an account can execute transactions that will modify critical data."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Treating accounts as user input is a fundamental principle in building secure and robust Solana programs.")),(0,i.kt)("h2",{id:"example-1-native-rust-program"},"Example 1: Native Rust Program"),(0,i.kt)("h3",{id:"context"},"Context"),(0,i.kt)("p",null,"In the provided example, we have a Native Solana program that includes an ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," struct and an entrypoint function called ",(0,i.kt)("inlineCode",{parentName:"p"},"process_instruction"),". This function is responsible for managing the program's logic. Let's analyze the program and then explore the consequences of missing the signer check on lines 19 to 21."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct IdentityAccount {\n    pub counter: u32,\n    pub authority: Pubkey,\n}\n\nentrypoint!(process_instruction);\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    let signer = next_account_info(accounts_iter)?;\n    let identity_account = next_account_info(accounts_iter)?;\n\n    // highlight-next-line\n    if !signer.is_signer {\n        // highlight-next-line\n        return Err(ProgramError::MissingRequiredSignature);\n    // highlight-next-line\n    }\n\n    if identity_account.owner != program_id {\n        return Err(ProgramError::IncorrectProgramId);\n    }\n\n    let mut identity = IdentityAccount::try_from_slice(&identity_account.data.borrow())?;\n    if signer.key != identity.authority {\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    identity.counter += 1;\n    identity.serialize(&mut &mut account.data.borrow_mut()[..])?;\n\n    Ok(())\n}\n\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"}," The program intentionally omits certain features to keep it small and compact. One crucial feature that is missing is the ability to create an ",(0,i.kt)("strong",{parentName:"p"},"IdentityAccount")," account and set the authority field. Consequently, the provided code assumes that the some ",(0,i.kt)("strong",{parentName:"p"},"IdentityAccount"),"  accounts already exists with the authority field appropriately set.")),(0,i.kt)("h3",{id:"program-analysis"},"Program Analysis"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," struct contains two fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"authority")," (a Pubkey representing the authority allowed to update the counter).")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The function begins by obtaining the first two accounts from the accounts array - ",(0,i.kt)("inlineCode",{parentName:"p"},"signer")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"identity_account"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The program then performs three crucial checks:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Signer Check")," (Line 19): It verifies if the signer account is a signer of the transaction by checking the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_signer")," field. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_signer")," flag is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", the program returns an error with ProgramError::MissingRequiredSignature, indicating that the transaction must be signed to proceed further.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Ownership Check")," (Line 23): It ensures that the ",(0,i.kt)("inlineCode",{parentName:"p"},"identity_account")," is associated with the correct program by checking if its owner field matches the `program_id``. If the owner doesn't match, the program returns an error with ProgramError::IncorrectProgramId.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Logic Check")," (Line 28): It validates that the signer is the rightful ",(0,i.kt)("inlineCode",{parentName:"p"},"authority")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"identity_account"),". If the validation fails, the program returns an error with ProgramError::InvalidAccountData.")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"After passing all checks, the program increments the ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," struct and then serializes it back to the account data."))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("strong",{parentName:"p"},"Ownership Check")," in the provided code could be omitted, as the Solana runtime inherently ensures that a program cannot modify an account it does not own. ")),(0,i.kt)("h3",{id:"consequence"},"Consequence"),(0,i.kt)("p",null,"If the signer check on lines 19 to 21 was missing, anyone could initiate a transaction with any arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," and its associated ",(0,i.kt)("inlineCode",{parentName:"p"},"authority"),". The program would increment the counter and update the account regardless of whether the authority has signed the transaction."))}d.isMDXComponent=!0}}]);