"use strict";(self.webpackChunksolana_open_security_standard=self.webpackChunksolana_open_security_standard||[]).push([[887],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=i,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9749:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const r={},o="Missing Signer Check",s={unversionedId:"A02_account_validation/missing_signer_check",id:"A02_account_validation/missing_signer_check",title:"Missing Signer Check",description:"Description",source:"@site/docs/A02_account_validation/missing_signer_check.md",sourceDirName:"A02_account_validation",slug:"/A02_account_validation/missing_signer_check",permalink:"/solana-open-security-standard/docs/A02_account_validation/missing_signer_check",draft:!1,editUrl:"https://github.com/CanardMandarin/solana-open-security-standard/tree/main/docs/A02_account_validation/missing_signer_check.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"A02 - Account Validation",permalink:"/solana-open-security-standard/docs/A02_account_validation/"},next:{title:"Missing Ownership Check",permalink:"/solana-open-security-standard/docs/A02_account_validation/missing_ownership_check"}},c={},l=[{value:"Description",id:"description",level:2},{value:"How To Prevent",id:"how-to-prevent",level:2},{value:"Example 1: Native Rust Program",id:"example-1-native-rust-program",level:2},{value:"Context",id:"context",level:3},{value:"Program Analysis",id:"program-analysis",level:3},{value:"Consequence",id:"consequence",level:3}],u={toc:l},p="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"missing-signer-check"},"Missing Signer Check"),(0,i.kt)("h2",{id:"description"},"Description"),(0,i.kt)("p",null,'Vulnerabilities known as "Missing Signer Check" are security flaws that occur when the validation of a transaction signer is not properly implemented. On the Solana blockchain, transactions are signed by accounts using their corresponding private keys to authorize actions or state modifications. These signatures ensure that only the rightful owner of an account can make changes to its data.'),(0,i.kt)("p",null,'When a program fails to validate the signer\'s identity before executing a transaction or modifying sensitive data, it opens the door for potential malicious actors to exploit the program. The "Missing Signer Check" vulnerability essentially allows unauthorized parties to perform actions as if they were legitimate account owners, generally leading to harmful scenarios.'),(0,i.kt)("h2",{id:"how-to-prevent"},"How To Prevent"),(0,i.kt)("p",null,'Preventing "Missing Signer Check" vulnerabilities in Solana programs is straightforward. Developers have to validate the ',(0,i.kt)("inlineCode",{parentName:"p"},"is_signer")," field of the ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html"},"AccountInfo"))," struct. With this simple check, developers can ensure that only the rightful owner of an account can execute transactions that will modify critical data."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Treating accounts as user input is a fundamental principle in building secure and robust Solana programs.")),(0,i.kt)("h2",{id:"example-1-native-rust-program"},"Example 1: Native Rust Program"),(0,i.kt)("h3",{id:"context"},"Context"),(0,i.kt)("p",null,"Let's analyze the following Solana program and then explore the consequences of missing the signer check on lines 19 to 21."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct IdentityAccount {\n    pub counter: u32,\n    pub authority: Pubkey,\n}\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    let signer = next_account_info(accounts_iter)?;\n    let identity_account = next_account_info(accounts_iter)?;\n\n    // highlight-next-line\n    if !signer.is_signer {\n        // highlight-next-line\n        return Err(ProgramError::MissingRequiredSignature);\n    // highlight-next-line\n    }\n\n    if identity_account.owner != program_id {\n        return Err(ProgramError::IllegalOwner);\n    }\n\n    let mut identity = IdentityAccount::try_from_slice(&identity_account.data.borrow())?;\n    if *signer.key != identity.authority {\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    identity.counter = identity.counter.checked_add(1);\n    identity.serialize(&mut &mut account.data.borrow_mut()[..])?;\n\n    Ok(())\n}\n\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"}," The program intentionally omits certain features to keep it small and compact. The provided code assumes that the some ",(0,i.kt)("strong",{parentName:"p"},"IdentityAccount"),"  accounts already exists with the authority field appropriately set.")),(0,i.kt)("h3",{id:"program-analysis"},"Program Analysis"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," struct contains two fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"authority")," (a Pubkey representing the authority allowed to update the counter).")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The function begins by obtaining the first two accounts from the accounts array - ",(0,i.kt)("inlineCode",{parentName:"p"},"signer")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"identity_account"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The program then performs three crucial checks:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Signer Check")," (Line 17): It verifies if the signer account is a signer of the transaction by checking the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_signer")," field.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Ownership Check")," (Line 21): It ensures that the ",(0,i.kt)("inlineCode",{parentName:"p"},"identity_account")," is associated with the correct program by checking if its owner field matches the ",(0,i.kt)("inlineCode",{parentName:"p"},"program_id"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Logic Check")," (Line 26): It validates that the signer is the rightful ",(0,i.kt)("inlineCode",{parentName:"p"},"authority")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"identity_account"),".")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"After passing all checks, the program increments the ",(0,i.kt)("inlineCode",{parentName:"p"},"counter")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," struct and then serializes it back to the account data."))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("strong",{parentName:"p"},"Ownership Check")," in the provided code could be omitted, as the Solana runtime inherently ensures that a program cannot modify an account it does not own. ")),(0,i.kt)("h3",{id:"consequence"},"Consequence"),(0,i.kt)("p",null,"If the signer check on lines 17 to 19 was missing, anyone could initiate a transaction with any arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityAccount")," and its associated ",(0,i.kt)("inlineCode",{parentName:"p"},"authority"),". The program would increment the counter and update the account regardless of whether the authority has signed the transaction."))}d.isMDXComponent=!0}}]);