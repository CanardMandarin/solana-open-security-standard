"use strict";(self.webpackChunksolana_open_security_standard=self.webpackChunksolana_open_security_standard||[]).push([[233],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6081:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={description:"Learn how to prevent the Missing Program Validation vulnerability in Solana programs.",keywords:["Missing Program Validation","Solana program","Cross Program Invocation","program ID verification","validation","Solana vulnerability"]},o="Missing Program Validation",s={unversionedId:"A02_account_validation/missing_program_validation",id:"A02_account_validation/missing_program_validation",title:"Missing Program Validation",description:"Learn how to prevent the Missing Program Validation vulnerability in Solana programs.",source:"@site/docs/A02_account_validation/missing_program_validation.md",sourceDirName:"A02_account_validation",slug:"/A02_account_validation/missing_program_validation",permalink:"/solana-open-security-standard/docs/A02_account_validation/missing_program_validation",draft:!1,editUrl:"https://github.com/CanardMandarin/solana-open-security-standard/tree/main/docs/A02_account_validation/missing_program_validation.md",tags:[],version:"current",frontMatter:{description:"Learn how to prevent the Missing Program Validation vulnerability in Solana programs.",keywords:["Missing Program Validation","Solana program","Cross Program Invocation","program ID verification","validation","Solana vulnerability"]},sidebar:"sidebar",previous:{title:"Missing Ownership Check",permalink:"/solana-open-security-standard/docs/A02_account_validation/missing_ownership_check"},next:{title:"Account Confusion",permalink:"/solana-open-security-standard/docs/A02_account_validation/account_confusion"}},l={},c=[{value:"Description",id:"description",level:2},{value:"How To Prevent",id:"how-to-prevent",level:2},{value:"Example 1: Native Rust Program",id:"example-1-native-rust-program",level:2},{value:"Context",id:"context",level:3},{value:"Program Analysis",id:"program-analysis",level:3},{value:"Consequence",id:"consequence",level:3}],p={toc:c},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"missing-program-validation"},"Missing Program Validation"),(0,r.kt)("h2",{id:"description"},"Description"),(0,r.kt)("p",null,'The "Missing Program Validation" vulnerability is a security flaw that arises in the context of Cross Program Invocation (CPI). When one program invokes another program, it needs to verify the pubkey (program ID) of the program it intends to call. Failure to perform this validation creates the "Missing Program Validation" vulnerability. Malicious actors can exploit this weakness by deploying fake programs and tricking the invoking program into running instructions from the counterfeit program.'),(0,r.kt)("h2",{id:"how-to-prevent"},"How To Prevent"),(0,r.kt)("p",null,"Whenever performing Cross Program Invocation (CPI), explicitly verify the program ID (pubkey) of the invoked program."),(0,r.kt)("h2",{id:"example-1-native-rust-program"},"Example 1: Native Rust Program"),(0,r.kt)("h3",{id:"context"},"Context"),(0,r.kt)("p",null,"Let's analyze the following program and explore the consequence of missing the program validation on lines 14 to 16."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'pub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    _instruction_data: &[u8],\n) -> ProgramResult {\n    let accounts_iter = &mut accounts.iter();\n\n    let system_program = next_account_info(accounts_iter)?;\n    let metadata_program = next_account_info(accounts_iter)?;\n    let signer = next_account_info(accounts_iter)?;\n    let mint = next_account_info(accounts_iter)?;\n    let metadata = next_account_info(accounts_iter)?;\n    let authority = next_account_info(accounts_iter)?;\n\n    // highlight-next-line\n    if *system_program.key != system_program::ID {\n        // highlight-next-line\n        return Err(ProgramError::IncorrectProgramId);\n    // highlight-next-line\n    }\n\n    // highlight-next-line\n    if *metadata_program.key != mpl_token_metadata::ID {\n        // highlight-next-line\n        return Err(ProgramError::IncorrectProgramId);\n    // highlight-next-line\n    }\n\n    if !signer.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    if *mint.owner != spl_token::ID {\n        return Err(ProgramError::IllegalOwner);\n    }\n\n    let _ = spl_token::state::Mint::unpack(*mint.data.borrow())?;\n\n    if *metadata.key != find_metadata_account(mint.key).0 {\n        return Err(ProgramError::InvalidArgument);   \n    }\n\n    let (expected_authority, nonce) = Pubkey::find_program_address(&[b"authority"], &program_id);\n    if *authority.key != expected_authority {\n        return Err(ProgramError::InvalidArgument);\n    }\n\n    invoke_signed(\n        &create_metadata_accounts_v3(\n            metadata_program.key(),\n            metadata_account.key(),\n            mint.key(),\n            authority.key(),\n            signer.key(),\n            authority.key(),\n            METADATA_NAME.to_string(),\n            METADATA_SYMBOL.to_string(),\n            METADATA_URI.to_string(),\n            None,\n            0,\n            false,\n            true,\n            None,\n            None,\n            None,\n        ),\n        &[\n            metadata_account.to_account_info(),\n            mint.to_account_info(),\n            authority.to_account_info(),\n            authority.to_account_info(),\n            signer.to_account_info(),\n            metadata_program.to_account_info(),\n            system_program.to_account_info(),\n            rent.to_account_info(),\n        ],\n        &[&[&b"authority"[..], &[nonce]]]\n    )?;\n\n    Ok(())\n}\n')),(0,r.kt)("h3",{id:"program-analysis"},"Program Analysis"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The function begins by obtaining the first fives accounts from the accounts array - ",(0,r.kt)("inlineCode",{parentName:"p"},"system_program"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata_program"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"signer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"mint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"authority"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The program then performs multiples checks:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Program Validation")," (Line 15 & 19):\nIt verifies whether the ",(0,r.kt)("inlineCode",{parentName:"p"},"system_program")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata_program")," account's key respectively match ",(0,r.kt)("inlineCode",{parentName:"p"},"system_program::ID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mpl_token_metadata::ID"),". ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Signer Check")," (Line 23): It verifies if the signer account is a signer of the transaction by checking the ",(0,r.kt)("inlineCode",{parentName:"p"},"is_signer")," field.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Ownership Check")," (Line 27): It ensures that the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," account is owned by the Token Program.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Account Check")," (Line 31): It ensures that the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," account is indeed a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/spl-token/4.0.0/spl_token/state/struct.Mint.html"},"Mint")," and not a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/spl-token/4.0.0/spl_token/state/struct.Account.html"},"Token Account"),", as both account are created by the Token Program.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"PDA Check")," (Line 33): It verifies that the ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata")," account is associated the to given ",(0,r.kt)("inlineCode",{parentName:"p"},"mint"),". Metadata accounts are PDA derived from the mint, therefore programs have to ensure that metadata accounts are associated with the right mint. In this scenario, the check could be omitted as the Metadata program will do it when called.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Logic Check")," (Line 37): It validates that the ",(0,r.kt)("inlineCode",{parentName:"p"},"authority")," account is the rightful authority.")))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If all checks pass successfully, the program proceeds to call the Metadata program in order to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata")," account for the mint."))),(0,r.kt)("h3",{id:"consequence"},"Consequence"),(0,r.kt)("p",null,"If the program validation were missing on lines 15 an 19, someone could supply their own malicious program instead of the ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata_program"),". The program could execute arbitrary code while having the permission over the ",(0,r.kt)("inlineCode",{parentName:"p"},"authority")," because of the ",(0,r.kt)("inlineCode",{parentName:"p"},"invoke_signed"),"."))}u.isMDXComponent=!0}}]);